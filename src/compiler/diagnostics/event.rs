//! The Events which can be created by the compiler for the purpose
//! of tracing and visibility into what the compiler is doing.

use std::fmt::Debug;

use crate::compiler::{CompilerDisplay, CompilerError, Span};

use super::{Writable, Writer};

/// Module for blocking access to any event id information from any other
/// part of the compiler
mod event_id {
    use std::sync::atomic::AtomicU64;

    use super::{Writable, Writer};
    /// Threadsafe mechanism for providing unique IDs for every event
    static NEXT_EVENT_ID: AtomicU64 = AtomicU64::new(1);

    /// Uniquely identifies each [`Event`] generated by the compiler.
    /// This unique ID can then be used for exact causative connections
    /// between events.
    pub struct EventId(u64);

    impl EventId {
        pub fn new() -> EventId {
            // Get a new unique event id
            let id = NEXT_EVENT_ID.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
            EventId(id)
        }
    }

    impl Writable for EventId {
        fn write(&self, w: &dyn Writer) {
            w.write_u64(self.0);
        }
    }
}

/// An event from any stage in the Compiler caused by the given span of source
/// code.
pub struct Event<'a, V: Writable, E: CompilerDisplay + Debug> {
    pub id: event_id::EventId,

    /// The stage of compilation that generated this event
    pub stage: &'a str,

    /// The [`Span`] of input source code that caused this event to occur
    pub input: Span,

    /// A description of the event
    pub msg: Result<V, &'a CompilerError<E>>,
}

impl<'a, V: Writable, E: CompilerDisplay + Debug> Event<'a, V, E> {
    pub fn new(
        stage: &'a str,
        input: Span,
        msg: Result<V, &'a CompilerError<E>>,
    ) -> Event<'a, V, E> {
        let id = event_id::EventId::new();
        Event {
            id,
            stage,
            input,
            msg,
        }
    }
}

impl<'a, V: Writable, E: CompilerDisplay + Debug> Writable for Event<'a, V, E> {
    fn write(&self, w: &dyn Writer) {
        w.start_event();
        w.write_field("id", &self.id);
        w.write_field("stage", &self.stage);
        w.write_span("source", self.input);
        match &self.msg {
            Ok(msg) => w.write_field("ok", msg),
            Err(err) => w.write_field("error", err),
        }
        w.stop_event();
    }
}
